import binascii
from cryptography.hazmat.primitives.cmac import CMAC
from cryptography.hazmat.primitives.ciphers import algorithms
from cryptography.hazmat.backends import default_backend

def reverse_words(data):
    """
    Reverse every 4-byte word in data.
    Use this if your MCU stores data as 32-bit words in little endian.
    For an all-zero array this function has no effect.
    """
    if len(data) % 4 != 0:
        raise ValueError("Data length must be a multiple of 4")
    return b"".join(data[i:i+4][::-1] for i in range(0, len(data), 4))

def compute_aes_cmac(key, message):
    # If needed, reverse each 4-byte word (uncomment the lines below)
    # key = reverse_words(key)
    # message = reverse_words(message)
    
    cobj = CMAC(algorithms.AES(key), backend=default_backend())
    cobj.update(message)
    return cobj.finalize()

if __name__ == '__main__':
    # Define the 16-byte AES key (all zeros, as in your pKeyAES)
    key = bytes([0x00] * 16)
    
    # Define the message you wish to authenticate.
    # For example, you can change this to any message you like.
    message = b"000003200000000000330034003d002100050003000600050005000300030004000400010003000600070007000f00140057006900720055002b002a002c00170009000500030004000300050003000300020004000b0008007f00da00dc006e002100100009000d000900030003000300020006000a000700020001000000000083005e007c00250009000400020001000400030001000000020003000100000000000000000000002a00280037002b000e00080007000600060003000200020003000300020001000000000000000000220051003b001f00090003000200020001000100030002000100010002000100020002000000000044007800f800560011000300010008000300000002000000030006000100020001000000000000008100ea00910036000e0004000300020001000100000000000300020000000000000000000000000085008d0062003d001b0006000600030001000100000000000200030000000000000000000000000064003f00c8004e001a000700080004000200020003000000000000000200000000000000000000004d00770084003c00190004000500030002000200040001000000000000000000000000000000000043004c006a0032001b000d000b0007000400020001000100020001000100010000000100030004004900550053002300180009000700010003000b000100010001000000000000000000010000000000430068005700200015000f00050002000100020001000300000000000000000000000100020005002c00860060003b001d000c0007000f000e000b000400040002000300020002000100050007000e00420079006f001f0026001f000f0009000400040001000100000001000000000000000000020005007000a7012500640031001c000a00060006000c00070002000200010003000000000000000000000046005500d800bb002400160009000200020015000700000001000100020000000000000000000000a800f100ae009d005d001a00080008000c0015000b000c000e001200050000000000010000000000f1017102280160007f0016000e00090005000f000c0013001b003a002c00050002000900010000632eb330eaf012841ba378faa1abc910"

    HEADER_SIZE = 32
    # Compute the AES-CMAC tag over the message.
    tag = compute_aes_cmac(key, binascii.unhexlify(message[HEADER_SIZE:-32]))
    
    # Print results
    print("Computed AES-CMAC:", binascii.hexlify(tag).decode())
    print("Expected mac:     ", str(message[-32:])[2:-1])
    if binascii.hexlify(tag).decode() == str(message[-32])[2:-1]:
        print("Verification successful!")
    else:
        print("Verification failed!")


    message = b"0000032000000001000B000A000900030000000000000000000000000000000000000000000000000000000000000000000700060006000100000000000000000000000000000000000000000000000000000000000000000005000300000000000100000000000000000000000000000000000000000000000000000000000000030004000500030000000000000001000000000000000000000000000000000000000000000000000400060005000F000A0000000000000000000000000000000000000000000000000000000000000008000E000B001E001A0004000100000001000000000002000100000000000000000000000000000008001C001400090004000100010001000000000000000200000000000000000000000000000000000B002B0015000A0007000100020002000100010000000100010004000400010000000200020000000E0012001100090004000100010002000000000001000100010002000300000000000000000000000F001E0022001A00180006000200010003000100000001000000000000000000000000000000000014001500120011000C000200010001000100010001000000000000000000000000000000000000000D0008000500030001000000000001000100000000000000000000000000000000000000000000000900040004000000010000000100010000000000000000000000000000000000000000000000000009000A000900060008000200010001000400040001000000000000000000000000000000000000000900080003000400090001000100010000000000000000000000000000000000000000000000000007000E000B000600070004000600050002000000000000000000000000000000000000000000000006001A001400080003000300050002000100000000000000000000000000000000000000000000000C0016000E00090004000200020002000000000000000000000000000000000000000000000000000F0010000A00040002000100000002000000000000000000000000000000000000000000000000000B002A000C00060005000000010001000000000000000000000000000000000000000000000000"
    tag = b"C6A97CE36E79F03AD7D3F537381F9642"
    # Compute the AES-CMAC tag over the message.
    computed_tag = compute_aes_cmac(key, binascii.unhexlify(message[HEADER_SIZE//2 :]))
    print("Computed AES-CMAC:", binascii.hexlify(computed_tag).decode())
    print("Expected mac:     ", tag.decode())
    if binascii.hexlify(computed_tag).decode() == tag.decode():
        print("Verification successful!")
    else:
        print("Verification failed!")