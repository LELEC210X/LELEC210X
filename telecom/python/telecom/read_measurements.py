from collections import defaultdict
from pathlib import Path

import click
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


def simulation_output_callback(
    _ctx: click.Context, param: click.Parameter, value: Path
) -> Path | None:
    if not value.exists():
        if value == param.default:
            return None
        raise click.BadParameter(f"File {value!r} does not exist.")
    return value


@click.command()
@click.argument(
    "file",
    type=click.Path(exists=True, dir_okay=False, path_type=Path),
)
@click.option(
    "-p",
    "--payload-len",
    "payload_len",
    required=True,
    type=int,
)
@click.option(
    "--esn0-tol",
    default=1,
    help="Suppress outlier where ",
)
@click.option(
    "--quiet",
    is_flag=True,
    help="Suppress output. I.e., does not print the dataframe.",
)
@click.option(
    "--plot/--no-plot",
    is_flag=True,
    default=True,
    show_default=True,
    help="Show plots.",
)
@click.option(
    "--group-by-GRX",
    is_flag=True,
    default=False,
    help="Group the measurement data by GRX (RX gain) rather than noise applied",
)
@click.option(
    "--simulation-output",
    type=click.Path(dir_okay=False, path_type=Path),
    default=Path(__file__).parents[2] / "sim_outputs.csv",
    callback=simulation_output_callback,
    show_default=True,
)
def main(
    file: Path,
    payload_len: int,
    esn0_tol: float,
    quiet: bool,
    plot: bool,
    group_by_grx: bool,
    simulation_output: Path | None,
) -> None:
    """
    Read a measurements file generated by 'eval_limesdr_fpga.py'
    and plots the PER/EsN0 curve, plus CFO values.
    """
    expected_payload = np.arange(payload_len, dtype=np.uint8)
    num_bits = payload_len * 8

    data = defaultdict(list)
    with open(file) as f:
        for line in f.read().splitlines():
            if line.startswith("CFO"):
                cfo, sto = line.split(",")
                data["cfo"].append(float(cfo.split("=")[1]))
                data["sto"].append(int(sto.split("=")[1]))
            elif line.startswith("EsN0dB"):
                esn0, Grx, N0 = line.split(",")
                data["esn0"].append(float(esn0.split("=")[1]))
                data["Grx"].append(int(Grx.split("=")[1]))
                data["N0"].append(int(10*np.log10(float(N0.split("=")[1]))))
            elif line.startswith("packet"):
                *_, payload = line.split(",", maxsplit=2)
                payload = list(map(int, payload.split("=")[1][1:-1].split(",")))
                biterror = np.unpackbits(
                    expected_payload ^ np.array(payload, dtype=np.uint8)
                ).sum()
                invalid = 1 if biterror > 0 else 0
                data["biterror"].append(biterror)
                data["invalid"].append(invalid)

    if not quiet or plot:
        df = pd.DataFrame.from_dict(data)
        if not quiet:
            click.echo(df)

        if plot:

            def remove_outliers(group):
                median_esn0 = group["esn0"].median()
                return group[
                    (group["esn0"] >= median_esn0 - esn0_tol)
                    & (group["esn0"] <= median_esn0 + esn0_tol)
                ]

            _fig, ax = plt.subplots(1, 2, constrained_layout=True, figsize=(10, 4))
            ax[0].set_ylabel("Measured EsN0 (dB)")
            if group_by_grx:
                df.boxplot(ax=ax[0], column="esn0", by="Grx", grid=True)
                df = df.groupby("Grx", group_keys=False).apply(remove_outliers)
                df.boxplot(ax=ax[1], column="esn0", by="Grx", grid=True)
                ax[0].set_xlabel("RX Gain used (dB)")
                ax[1].set_xlabel("RX Gain used (dB)")
            else:
                df.boxplot(ax=ax[0], column="esn0", by="N0", grid=True)
                df = df.groupby("N0", group_keys=False).apply(remove_outliers)
                df.boxplot(ax=ax[1], column="esn0", by="N0", grid=True)
                ax[0].set_xlabel("N0 (dB)")
                ax[1].set_xlabel("N0 (dB)")

            #ax[0].grid(True)
            ax[0].set_title("Measured EsN0 distribution")
            ax[1].set_ylabel("Measured EsN0 (dB)")
            #ax[1].grid(True)
            ax[1].set_title("Measured EsN0 distribution after outlier removal")

            df.hist(column="cfo")
            plt.title("Histogram of estimated CFO")
            plt.suptitle("")
            plt.xlabel("Number")
            plt.ylabel("Frequency (Hz)")

            if group_by_grx:
                agg = (
                    df.groupby("Grx")
                    .agg(
                        esn0_mean=("esn0", "mean"),
                        per_mean=("invalid", "mean"),
                        biterror=("biterror", "sum"),
                        count=("biterror", "count"),
                    )
                    .reset_index()
                )
            else:
                agg = (
                    df.groupby("N0")
                    .agg(
                        esn0_mean=("esn0", "mean"),
                        per_mean=("invalid", "mean"),
                        biterror=("biterror", "sum"),
                        count=("biterror", "count"),
                    )
                    .reset_index()
                )

            ber = agg["biterror"] / (agg["count"] * num_bits)

            if simulation_output is not None:
                data = np.loadtxt(simulation_output)
                EsN0_db = data[:, 0]
                sim_BER = data[:, 1]
                sim_PER = data[:, 2]

                EsN0_th = 10 ** (EsN0_db / 10)
                BER_th_noncoh = 0.5 * np.exp(-(10 ** (EsN0_db / 10.0)) / 2)

                ax[0].plot(EsN0_db, BER_th_noncoh, label="AWGN Th. FSK non-coh.")
                ax[0].plot(EsN0_db, sim_BER, label="Simulation")

            _fig, ax = plt.subplots(1, 2, constrained_layout=True, figsize=(10, 4))
            ax[0].plot(agg["esn0_mean"], ber, "-s", label="Measurement")
            ax[0].set_ylabel("BER")
            ax[0].set_xlabel("$E_{s}/N_{0}$ [dB]")
            ax[0].set_yscale("log")
            ax[0].set_ylim((1e-4, 1))
            ax[0].grid(True)
            ax[0].set_title("Average Bit Error Rate")
            ax[0].legend()

            ax[1].plot(agg["esn0_mean"], agg["per_mean"], "-s", label="Measurement")

            if simulation_output is not None:
                ax[1].plot(
                    EsN0_db,
                    1 - (1 - BER_th_noncoh) ** num_bits,
                    label="AWGN Th. FSK non-coh.",
                )
                ax[1].plot(EsN0_db, sim_PER, label="Simulation")

            ax[1].set_ylabel("PER")
            ax[1].set_xlabel("$E_{s}/N_{0}$ [dB]")
            ax[1].set_yscale("log")
            ax[1].set_ylim((1e-4, 1))
            ax[1].grid(True)
            ax[1].set_title("Average Packet Error Rate")
            ax[1].legend()

            plt.show()


if __name__ == "__main__":
    main()
